{"version":3,"file":"spm.js","sources":["../../../src/spm/model/Group.kt","../../../src/spm/model/Password.kt","../../../../build/kotlin-js-min/main/text/Strings.kt","../../../../build/kotlin-js-min/main/collections/Maps.kt","../../../src/spm/SimplePasswordManager.kt","../../../src/spm/crypt/Crypt.kt","../../../../build/kotlin-js-min/main/kotlin/text/string.kt","../../../../build/kotlin-js-min/main/collections/Collections.kt","../../../src/spm/state/UserState.kt","../../../src/spm/util/Date.kt","../../../src/spm/util/Text.kt","../../../src/spm/util/Version.kt","../../../src/spm/view/ChangePassword.kt","../../../src/spm/view/Container.kt","../../../src/spm/view/GroupCommands.kt","../../../src/spm/view/GroupOverview.kt","../../../../build/kotlin-js-min/main/generated/_Collections.kt","../../../src/spm/view/Login.kt","../../../src/spm/view/Main.kt","../../../src/spm/view/Modal.kt","../../../src/spm/view/Navbar.kt","../../../src/spm/view/Notify.kt","../../../src/spm/view/PasswordEditor.kt","../../../src/spm/view/PasswordGenerator.kt","../../../src/spm/view/PasswordOverview.kt","../../../src/spm/view/PasswordOverviewRow.kt","../../../src/spm/view/SearchResult.kt","../../../src/spm/view/Styles.kt","../../../src/spm/view/button/PasswordButton.kt","../../../src/spm/view/input/SelectInput.kt","../../../src/spm/view/input/TextInput.kt","../../../src/spm/view/table/Table.kt","../../../src/spm/ws/CommandDispatcher.kt","../../../src/spm/ws/Tokenizer.kt","../../../src/spm/ws/WebSocketConnection.kt"],"sourcesContent":["package spm.model\n\nimport spm.ws.Tokenizer\n\n/**\n * User: rnentjes\n * Date: 11-1-17\n * Time: 11:28\n */\n\ndata class Group(\n  var id: Long,\n  var name: String,\n  var opened: Boolean = false,\n  var parent: Group?,\n  var found: Boolean = false,\n  val children: MutableList<Group> = ArrayList(),\n  val passwords: MutableList<Password> = ArrayList()\n) {\n    constructor(name: String, parent: Group) : this(nextId(), name, false, parent)\n\n    constructor(tk: Tokenizer) : this(tk.next().toLong(), tk.next(), tk.next() == \"true\", null) {\n        if (id > lastId) {\n            lastId = id\n        }\n        //console.log(\"Read group $name\", this)\n        val numberOfPasswords = tk.next().toInt()\n        //println(\"\\t Number of passwords :$numberOfPasswords\")\n        for (index in 0 until numberOfPasswords) {\n            val password = Password(tk, this)\n\n            passwords.add(password)\n        }\n\n        val numberOfChildren = tk.next().toInt()\n\n        //println(\"\\t Number of children :$numberOfChildren\")\n        // weird for-loop bug work-around\n        var index = 0\n        while (index < numberOfChildren) {\n            //println(\"\\t Child $index\")\n            val child = Group(tk)\n\n            child.parent = this\n            children.add(child)\n            index++\n        }\n    }\n\n    fun all(): List<Group> {\n        val result = ArrayList<Group>()\n\n        result.add(this)\n\n        for (child in children) {\n            result.addAll(child.all())\n        }\n\n        return result\n    }\n\n    fun export(): String {\n        val result = StringBuilder()\n        val tk = Tokenizer()\n\n        result.append(tk.tokenize(\"$id\", name, \"$opened\"))\n\n        result.append(tk.seperator)\n        result.append(passwords.size)\n        for (password in passwords) {\n            result.append(tk.seperator)\n            result.append(password.tokenized())\n        }\n\n        result.append(tk.seperator)\n        result.append(children.size)\n        for (child in children) {\n            result.append(tk.seperator)\n            result.append(child.export())\n        }\n\n        return result.toString()\n    }\n\n    fun findById(id: Long): Group? {\n        if (this.id == id) {\n            return this\n        } else {\n            for (child in children) {\n                val found = child.findById(id)\n\n                if (found != null) {\n                    return found\n                }\n            }\n        }\n\n        return null\n    }\n\n    fun getPasswordsCountInGroup(): Int {\n        var result = passwords.size\n\n        for (child in children) {\n            result += child.getPasswordsCountInGroup()\n        }\n\n        return result\n    }\n\n    fun getGroups(prefix: String = \"\"): List<Pair<String, String>> {\n        val result = ArrayList<Pair<String, String>>()\n\n        val childPrefix = if (prefix.isBlank()) {\n            name\n        } else {\n            \"$prefix / $name\"\n        }\n\n        result.add(\"$id\" to childPrefix)\n\n        for (child in children) {\n            result.addAll(child.getGroups(childPrefix))\n        }\n\n        return result\n    }\n\n    companion object {\n        private var lastId = 0L\n\n        fun nextId(): Long {\n            return ++lastId\n        }\n    }\n}","package spm.model\n\nimport spm.state.UserState\nimport spm.util.formatted\nimport spm.ws.Tokenizer\nimport kotlin.js.Date\n\n/**\n * User: rnentjes\n * Date: 11-1-17\n * Time: 11:28\n */\n\ndata class HistoryEntry(\n  var encryptedPassword: String,\n  var from: String,\n  var until: String\n) {\n\n    constructor(tk: Tokenizer): this(tk.next(), tk.next(), tk.next())\n\n    fun tokenized(): String = Tokenizer.tokenize(\n      encryptedPassword,\n      from,\n      until\n    )\n}\n\ndata class Password(\n  var id: Long,\n  var user: String,\n  var group: Group,\n  var title: String,\n  var website: String,\n  var username: String,\n  var encryptedPassword: String,\n  var password1: String = \"\",\n  var password2: String = \"\",\n  var description: String,\n  var created: String,\n  var history: MutableList<HistoryEntry> = ArrayList()\n) {\n    constructor(group: Group) : this(nextId(), \"\", group, \"\", \"\", \"\", \"\", \"\", \"\", \"\", Date().formatted())\n\n    constructor(other: Password) : this(\n      other.id,\n      other.user,\n      other.group,\n      other.title,\n      other.website,\n      other.username,\n      other.encryptedPassword,\n      other.password1,\n      other.password2,\n      other.description,\n      Date().formatted())\n\n    constructor(tk: Tokenizer, group: Group): this(-1, \"\", group, \"\", \"\", \"\", \"\", \"\", \"\", \"\", Date().formatted()) {\n        val first = tk.next()\n\n        when (first) {\n            \"V3\" -> {\n                id = tk.next().toLong()\n                user = tk.next()\n                title = tk.next()\n                website = tk.next()\n                username = tk.next()\n                encryptedPassword = tk.next()\n                description = tk.next()\n                created = tk.next()\n\n                val historyData = Tokenizer(tk.next())\n\n                while(!historyData.done()) {\n                    history.add(HistoryEntry(Tokenizer(historyData.next())))\n                }\n            }\n            \"V2\" -> {\n                id = tk.next().toLong()\n                user = tk.next()\n                title = tk.next()\n                website = tk.next()\n                username = tk.next()\n                encryptedPassword = tk.next()\n                description = tk.next()\n\n                val historyData = Tokenizer(tk.next())\n\n                while(!historyData.done()) {\n                    history.add(HistoryEntry(Tokenizer(historyData.next())))\n                }\n            }\n            else -> {\n                id = first.toLong()\n                user = tk.next()\n                title = tk.next()\n                website = tk.next()\n                username = tk.next()\n                encryptedPassword = tk.next()\n                description = tk.next()\n            }\n        }\n\n    }\n\n    fun tokenized(): String {\n        val tk = Tokenizer()\n        val tkHist = StringBuilder()\n\n        for(index in 0 until this.history.size) {\n            if (index > 0) {\n                tkHist.append(tk.seperator)\n            }\n            tkHist.append(Tokenizer.tokenize(this.history[index].tokenized()))\n        }\n\n        return Tokenizer.tokenize(\n          \"V3\",\n          \"$id\",\n          user,\n          title,\n          website,\n          username,\n          encryptedPassword,\n          description,\n          created,\n          tkHist.toString()\n        )\n    }\n\n    fun decrypt() {\n        password1 = UserState.decryptPassword(encryptedPassword)\n        password2 = password1\n    }\n\n    fun delete() {\n        group.passwords.remove(this)\n    }\n\n    companion object {\n        private var lastId = 0L\n\n        fun nextId(): Long = ++lastId\n    }\n\n    fun search(value: String): Boolean {\n        return username.toLowerCase().contains(value) ||\n          title.toLowerCase().contains(value) ||\n          website.toLowerCase().contains(value) ||\n          description.toLowerCase().contains(value)\n    }\n\n    fun archivePassword() {\n        history.add(HistoryEntry(\n          encryptedPassword, created, Date().formatted()\n        ))\n    }\n\n    fun hasHistory() = history.isNotEmpty()\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.contract\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n *\n * @sample samples.text.Strings.stringIsNullOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n *\n * @sample samples.text.Strings.stringIsEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n *\n * @sample samples.text.Strings.stringIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNotBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNullOrBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.append(this, 0, startIndex)\n    sb.append(replacement)\n    sb.append(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.append(this, 0, startIndex)\n    sb.append(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonPrefixWith\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonSuffixWith\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" } )\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n *\n * @sample samples.collections.Maps.Instantiation.emptyHashMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Calculate the initial capacity of a map, based on Guava's com.google.common.collect.Maps approach. This is equivalent\n * to the Collection constructor for HashSet, (c.size()/.75f) + 1, but provides further optimisations for very small or\n * very large sizes, allows support non-collection classes, and provides consistency for all map based class construction.\n */\n@PublishedApi\ninternal fun mapCapacity(expectedSize: Int): Int {\n    if (expectedSize < 3) {\n        return expectedSize + 1\n    }\n    if (expectedSize < INT_MAX_POWER_OF_TWO) {\n        return expectedSize + expectedSize / 3\n    }\n    return Int.MAX_VALUE // any large value\n}\n\nprivate const val INT_MAX_POWER_OF_TWO: Int = Int.MAX_VALUE / 2 + 1\n\n/** Returns `true` if this map is not empty. */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable map is either null or empty.\n * @sample samples.collections.Maps.Usage.mapIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || isEmpty()\n}\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n *\n * @sample samples.collections.Maps.Usage.mapOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Returns this map if it's not empty\n * or the result of calling [defaultValue] function if the map is empty.\n *\n * @sample samples.collections.Maps.Usage.mapIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <M, R> M.ifEmpty(defaultValue: () -> R): R where M : Map<*, *>, M : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n *\n * @sample samples.collections.Maps.Usage.containsValue\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","package spm\n\nimport nl.astraeus.komp.Komponent\nimport spm.view.Main\nimport spm.ws.WebSocketConnection\nimport kotlin.browser.document\n\n/**\n * User: rnentjes\n * Date: 20-11-16\n * Time: 12:24\n */\n\nval mainComponent = Main()\n\nfun main() {\n    val splash = document.getElementById(\"splash\")\n\n    splash?.parentElement?.removeChild(splash)\n\n    Komponent.logRenderEvent = false\n    Komponent.logReplaceEvent = false\n\n    Komponent.create(document.body!!, mainComponent)\n\n    WebSocketConnection.open()\n}\n","package spm.crypt\n\n/**\n * User: rnentjes\n * Date: 26-11-16\n * Time: 12:51\n *\n * requires: <script src=\"https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/aes.js\"></script>\n */\n\nobject Aes {\n\n    fun encrypt(plaintext: String, passphrase: String) = js(\"CryptoJS.AES.encrypt(plaintext, passphrase);\")\n\n    fun decrypt(encrypted: String, passphrase: String) = js(\"CryptoJS.AES.decrypt(encrypted, passphrase).toString(CryptoJS.enc.Utf8);\")\n\n}\n\n/**\n * requires: <script src=\"https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/sha256.js\"></script>\n * requires: <script src=\"https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/sha512.js\"></script>\n */\nobject Hash {\n\n    fun sha256(plaintext: String) = js(\"CryptoJS.SHA256(plaintext);\")\n\n    fun sha512(plaintext: String) = js(\"CryptoJS.SHA512(plaintext);\")\n\n}\n\nobject PBKDF2 {\n\n    fun genKey(passphrase: String, salt: dynamic, keySize: Int) = \"${js(\"CryptoJS.PBKDF2(passphrase, salt, { keySize: keySize });\")}\"\n\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n *\n * @sample samples.text.Strings.toUpperCase\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n *\n * @sample samples.text.Strings.toLowerCase\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        var start = 0\n        while (true) {\n            val end = minOf(start + 16, min)\n            var s1 = this.substring(start, end)\n            var s2 = other.substring(start, end)\n            if (s1 != s2) {\n                s1 = s1.toUpperCase()\n                s2 = s2.toUpperCase()\n                if (s1 != s2) {\n                    s1 = s1.toLowerCase()\n                    s2 = s2.toLowerCase()\n                    if (s1 != s2) {\n                        return s1.compareTo(s2)\n                    }\n                }\n            }\n            if (end == min) break\n            start = end\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","package spm.state\n\nimport spm.crypt.Aes\nimport spm.model.Group\nimport spm.ws.Tokenizer\nimport spm.ws.WebSocketConnection\nimport spm.view.Modal\n\n/**\n * User: rnentjes\n * Date: 26-11-16\n * Time: 16:14\n */\n\nobject UserState {\n    var loginname: String? = null\n    set(value) {\n        val crypto = js(\"CryptoJS\")\n\n        field = crypto.SHA256(value).toString()\n    }\n    var loginPasswordHash: String? = null\n    var encryptedEncryptionKey: String? = null\n    var loggedIn = false\n\n    // groups\n    var currentGroup: Group? = null\n    var topGroup: Group? = null\n    var currentSearch: String = \"\"\n\n    var readOnly: Boolean = true\n    var obtainedLock: Boolean = false\n\n    private var decryptPassphraseHash: String? = null\n\n    fun clear() {\n        loginname = null\n        loginPasswordHash = null\n        decryptPassphraseHash = null\n        encryptedEncryptionKey = null\n        topGroup = null\n        currentGroup = null\n        loggedIn = false\n        readOnly = true\n    }\n\n    fun decryptPassword(password: String): String {\n        val pp: String = decryptPassphraseHash ?: throw IllegalStateException(\"passphraseHash is not set\")\n        val eek: String = encryptedEncryptionKey ?: throw IllegalStateException(\"passphraseHash is not set\")\n\n        val decryptedEncryptionKey = Aes.decrypt(eek, pp).toString()\n\n        return Aes.decrypt(password, decryptedEncryptionKey).toString()\n    }\n\n    fun encryptPassword(password: String): String {\n        val pp: String = decryptPassphraseHash ?: throw IllegalStateException(\"passphraseHash is not set\")\n        val eek: String = encryptedEncryptionKey ?: throw IllegalStateException(\"passphraseHash is not set\")\n\n        val decryptedEncryptionKey = Aes.decrypt(eek, pp).toString()\n\n        return Aes.encrypt(password, decryptedEncryptionKey).toString()\n    }\n\n    fun setPassword(password: String) {\n        val crypto = js(\"CryptoJS\")\n\n        val sha256 = crypto.SHA256(password)\n        val sha512 = crypto.SHA512(password)\n\n        loginPasswordHash = \"${js(\"CryptoJS.PBKDF2(sha256, sha512, { keySize: 256 / 32, iterations: 500 });\")}\"\n        decryptPassphraseHash = \"${js(\"CryptoJS.PBKDF2(sha256, sha512, { keySize: 256 / 32, iterations: 750 });\")}\"\n    }\n\n    fun updatePassword(currentPassword: String, newPassword1: String, newPassword2: String): Boolean {\n        val crypto = js(\"CryptoJS\")\n\n        val sha256 = crypto.SHA256(currentPassword)\n        val sha512 = crypto.SHA512(currentPassword)\n\n        val currentPasswordHash = \"${js(\"CryptoJS.PBKDF2(sha256, sha512, { keySize: 256 / 32, iterations: 500 });\")}\"\n\n        if (!currentPasswordHash.equals(loginPasswordHash)) {\n            Modal.showAlert(\"Fail\", \"Wrong passphrase entered\")\n\n            return false\n        }\n\n        if (newPassword1.isEmpty() || !newPassword1.equals(newPassword2)) {\n            Modal.showAlert(\"Fail\", \"New passphrases don't match\")\n\n            return false\n        }\n\n        WebSocketConnection.loadingWork {\n            val pp: String = decryptPassphraseHash ?: throw IllegalStateException(\"passphraseHash is not set\")\n            val eek: String = encryptedEncryptionKey ?: throw IllegalStateException(\"passphraseHash is not set\")\n\n            val decryptedEncryptionKey = Aes.decrypt(eek, pp).toString()\n\n            setPassword(newPassword1)\n\n            val newPP: String = decryptPassphraseHash ?: throw IllegalStateException(\"passphraseHash is not set\")\n\n            val newEEK = Aes.encrypt(decryptedEncryptionKey, newPP)\n            encryptedEncryptionKey = newEEK.toString()\n\n            WebSocketConnection.send(\"UPDATE_PASSWORD\",\n              UserState.loginname ?: throw IllegalStateException(\"Whut!\"),\n              UserState.loginPasswordHash ?: throw IllegalStateException(\"Whut!\"),\n              newEEK.toString()\n            )\n        }\n\n        return true\n    }\n\n    /** create encryption key and return encrypted encryption key */\n    fun createEncryptionKey(): String {\n        val pp: String = decryptPassphraseHash ?: throw IllegalStateException(\"passphraseHash is not set\")\n\n        val base64String = \"${js(\"CryptoJS.enc.Base64.stringify(CryptoJS.lib.WordArray.random(64));\")}\"\n\n        return Aes.encrypt(base64String, pp).toString()\n    }\n\n    fun loadData(data: String) {\n        val pp: String = decryptPassphraseHash ?: throw IllegalStateException(\"passphraseHash is not set\")\n        val eek: String = encryptedEncryptionKey ?: throw IllegalStateException(\"encryptedEncryptionKey is not set\")\n\n        val decryptedEncryptionKey = Aes.decrypt(eek, pp).toString()\n        val decryptedData = Aes.decrypt(data, decryptedEncryptionKey).toString()\n\n        //console.log(\"IMPORT: \", decryptedData)\n\n        if (decryptedData.isBlank()) {\n            topGroup = Group(0, \"Root\", false, null, false, ArrayList(), ArrayList())\n        } else {\n            val tk = Tokenizer(decryptedData)\n            topGroup = Group(tk)\n            //while (!tk.done()) {\n                //println(\"!DONE: ${tk.next()}\")\n            //}\n        }\n    }\n\n    fun saveData() {\n        if (!readOnly) {\n            val pp: String = decryptPassphraseHash ?: throw IllegalStateException(\"passphraseHash is not set\")\n            val eek: String = encryptedEncryptionKey ?: throw IllegalStateException(\"passphraseHash is not set\")\n\n            val decryptedEncryptionKey = Aes.decrypt(eek, pp).toString()\n            val tg = topGroup\n\n            if (tg != null) {\n                val export = tg.export()\n\n                //console.log(\"EXPORT: \", export)\n\n                val data = Aes.encrypt(export, decryptedEncryptionKey).toString()\n\n                WebSocketConnection.send(\"SAVEDATA\", data)\n            }\n        } else {\n            throw IllegalStateException(\"Can't save in readOnly mode!\")\n        }\n    }\n\n    fun logout() {\n        WebSocketConnection.send(\"LOGOUT\")\n\n        clear()\n    }\n}\n","package spm.util\n\nimport kotlin.js.Date\n\nfun Date.formatted(): String {\n    val result = StringBuilder()\n    val date = this\n    val month = \"${js(\"date.getMonth() + 1\")}\"\n    val day = \"${js(\"date.getDate()\")}\"\n    val hour = \"${js(\"date.getHours()\")}\"\n    val minute = \"${js(\"date.getMinutes()\")}\"\n\n    result.append(\"${js(\"date.getFullYear()\")}\")\n    result.append(\"-\")\n    result.append(if (month.length == 1) { \"0$month\" } else { month })\n    result.append(\"-\")\n    result.append(if (day.length == 1) { \"0$day\" } else { day })\n\n    result.append(\" \")\n    result.append(if (hour.length == 1) { \"0$hour\" } else { hour })\n    result.append(\":\")\n    result.append(if (minute.length == 1) { \"0$minute\" } else { minute })\n\n    return result.toString()\n}\n","package spm.util\n\nimport kotlinx.html.Tag\nimport kotlinx.html.TagConsumer\nimport kotlinx.html.td\nimport kotlinx.html.title\nimport org.w3c.dom.HTMLElement\nimport org.w3c.dom.HTMLTextAreaElement\nimport kotlin.browser.document\n\n/**\n * User: rnentjes\n * Date: 8-11-17\n * Time: 17:44\n */\n\nfun Tag.trimmed(str: String, length: Int) = consumer.td {\n    if (str.length > length) {\n        title = str\n        +\"${str.substring(0 until length - 3)}...\"\n    } else {\n        +str\n    }\n}\n\nfun copyToClipboard(\n  text: String,\n  parentToAppendTo: HTMLElement = document.body ?: throw IllegalStateException(\"The body was not found!\")\n) {\n    val ta = document.createElement(\"textarea\")\n    ta.innerHTML = text\n\n    if (ta is HTMLTextAreaElement) {\n        parentToAppendTo.appendChild(ta)\n        ta.select()\n        document.execCommand(\"copy\")\n        parentToAppendTo.removeChild(ta)\n    } else {\n        throw IllegalStateException(\"Created element isn't HTMLTextAreaElement but $ta\")\n    }\n}\n","package spm.util\n\nobject Version {\n  val version = \"v. 1.7.6\"\n}\n","package spm.view\n\nimport kotlinx.html.TagConsumer\nimport kotlinx.html.form\nimport kotlinx.html.js.div\nimport nl.astraeus.komp.HtmlBuilder\nimport nl.astraeus.komp.Komponent\nimport nl.astraeus.komp.include\nimport org.w3c.dom.HTMLElement\nimport org.w3c.dom.HTMLInputElement\nimport spm.view.input.TextInput\n\n/**\n * User: rnentjes\n * Date: 5-4-17\n * Time: 9:46\n */\n\nclass ChangePassword : Komponent() {\n\n  var currentPassword = \"\"\n    var newPassword1 = \"\"\n    var newPassword2 = \"\"\n\n    override fun render(consumer: HtmlBuilder) = consumer.div(classes = \"col-md-12\") {\n\n        form(classes = \"form form-horizontal\") {\n\n            include(TextInput(\"current_password\", \"Current passphrase\", \"\",\n              labelWidth = 4,\n              blur = { e ->\n                  currentPassword = (e.target as HTMLInputElement).value\n              },\n              change = { e ->\n                  currentPassword = (e.target as HTMLInputElement).value\n              }))\n            include(TextInput(\"new_password1\", \"New passphrase\", \"\",\n              labelWidth = 4,\n              blur = { e ->\n                  newPassword1 = (e.target as HTMLInputElement).value\n              },\n              change = { e ->\n                  newPassword1 = (e.target as HTMLInputElement).value\n              }))\n            include(TextInput(\"new_password2\", \"Confirm new passphrase\", \"\",\n              labelWidth = 4,\n              blur = { e ->\n                  newPassword2 = (e.target as HTMLInputElement).value\n              },\n              change = { e ->\n                  newPassword2 = (e.target as HTMLInputElement).value\n              }))\n\n        }\n    }\n\n}\n","package spm.view\n\nimport kotlinx.html.TagConsumer\nimport kotlinx.html.div\nimport kotlinx.html.js.div\nimport nl.astraeus.komp.HtmlBuilder\nimport nl.astraeus.komp.Komponent\nimport nl.astraeus.komp.include\nimport org.w3c.dom.HTMLElement\nimport spm.state.UserState\n\n/**\n * Created by rnentjes on 3-4-17.\n */\n\nclass Container(main: Komponent): Komponent() {\n    val groupOverview = GroupOverview(this)\n    val passwordOverview = PasswordOverview(this)\n    val searchResult = SearchResult(this)\n\n    override fun render(consumer: HtmlBuilder) = consumer.div {\n        div(classes = \"container\") {\n            include(groupOverview)\n            if (UserState.currentSearch.isBlank()) {\n                include(passwordOverview)\n            } else {\n                include(searchResult)\n            }\n        }\n    }\n\n}\n","package spm.view\n\nimport kotlinx.html.a\nimport kotlinx.html.div\nimport kotlinx.html.js.onClickFunction\nimport kotlinx.html.style\nimport nl.astraeus.komp.HtmlBuilder\nimport nl.astraeus.komp.Komponent\nimport spm.main\nimport spm.mainComponent\nimport spm.model.Group\nimport spm.state.UserState\nimport spm.ws.WebSocketConnection\n\nclass GroupCommands(\n    val cg: Group,\n    val refreshContainer: Komponent\n) : Komponent() {\n\n  fun rename(group: Group) {\n    WebSocketConnection.lock { ws, tk ->\n      val response = tk.next()\n\n      if (response == \"LOCKED\") {\n        val renameSubgroup = GroupNameEdit(group.name)\n        UserState.readOnly = false\n        UserState.obtainedLock = true\n        mainComponent.update()\n        Modal.openModal(\n            \"Add group\",\n            renameSubgroup,\n            okText = \"Save\",\n            okButtonClass = \"btn-success\",\n            ok = {\n              if (renameSubgroup.groupname.isBlank()) {\n                //Notify.show(\"Group name can not be blank!\", \"error\")\n                Modal.showAlert(\"Error\", \"Group name can not be blank\")\n              } else {\n                group.name = renameSubgroup.groupname\n                UserState.saveData()\n                refreshContainer.update()\n              }\n\n              true\n            },\n            cancel = {\n              ws.send(\"UNLOCK\")\n            }\n        )\n      } else {\n        Modal.showAlert(\"Blocked\", \"Unable to obtain modify lock.\")\n      }\n    }\n  }\n\n  fun addSubgroup(group: Group) {\n    WebSocketConnection.lock { ws, tk ->\n      val response = tk.next()\n\n      if (response == \"LOCKED\") {\n        val addSubgroup = GroupNameEdit()\n        Modal.openModal(\n            \"Add group\",\n            addSubgroup,\n            okText = \"Save\",\n            okButtonClass = \"btn-success\",\n            ok = {\n              if (addSubgroup.groupname.isBlank()) {\n                //Notify.show(\"Group name can not be blank!\", \"error\")\n                Modal.showAlert(\"Error\", \"Group name can not be blank\")\n              } else {\n                val newGroup = Group(addSubgroup.groupname, group)\n                group.children.add(newGroup)\n\n                UserState.saveData()\n                refreshContainer.update()\n              }\n\n              true\n            },\n            cancel = {\n              ws.send(\"UNLOCK\")\n            }\n        )\n      } else {\n        Modal.showAlert(\"Blocked\", \"Unable to obtain modify lock.\")\n      }\n    }\n  }\n\n  fun removeGroup(group: Group) {\n    WebSocketConnection.lock { ws, tk ->\n      val response = tk.next()\n\n      if (response == \"LOCKED\") {\n        val removeSubGroup = RemoveGroupConfirm(group.name)\n        Modal.openModal(\n            \"Remove group\",\n            removeSubGroup,\n            okText = \"Remove\",\n            okButtonClass = \"btn-danger\",\n            ok = {\n              group.parent?.children?.remove(group)\n\n              UserState.saveData()\n              refreshContainer.update()\n\n              true\n            },\n            cancel = {\n              ws.send(\"UNLOCK\")\n            }\n        )\n      } else {\n        Modal.showAlert(\"Blocked\", \"Unable to obtain modify lock.\")\n      }\n    }\n  }\n\n  override fun render(consumer: HtmlBuilder) = consumer.div(classes = \"col-md-6\") {\n    style = \"margin-top: 20px;\"\n    a(classes = \"btn btn-success btn-sm\") {\n      +\"Rename\"\n      onClickFunction = {\n        rename(cg)\n      }\n    }\n    a(classes = \"btn btn-primary btn-sm\") {\n      style = \"margin-left:5px;\"\n      +\"Add subgroup\"\n      onClickFunction = {\n        addSubgroup(cg)\n      }\n    }\n    a(classes = \"btn btn-danger btn-sm\") {\n      style = \"margin-left:5px;\"\n      if (cg.children.isNotEmpty() || cg.passwords.isNotEmpty() || cg.parent == null) {\n        attributes[\"disabled\"] = \"disabled\"\n      }\n      +\"Remove group\"\n      onClickFunction = {\n        if (cg.children.isEmpty() && cg.passwords.isEmpty() && cg.parent != null) {\n          removeGroup(cg)\n        }\n      }\n    }\n  }\n}\n","package spm.view\n\nimport kotlinx.html.*\nimport kotlinx.html.js.div\nimport kotlinx.html.js.onClickFunction\nimport nl.astraeus.komp.HtmlBuilder\nimport nl.astraeus.komp.Komponent\nimport nl.astraeus.komp.include\nimport org.w3c.dom.HTMLElement\nimport spm.model.Group\nimport spm.state.UserState\nimport spm.state.UserState.topGroup\nimport spm.ws.WebSocketConnection\n\n/**\n * Created by rnentjes on 4-4-17.\n */\n\nfun HtmlBlockTag.groupOverview(container: Komponent) {\n  include(GroupOverview(container))\n}\n\nclass GroupOverview(val container: Komponent) : Komponent() {\n\n  init {\n    style(\"selected\", Styles.selected)\n    style(\"found\", Styles.found)\n  }\n\n  private fun createGroup(consumer: TagConsumer<HTMLElement>, topGroup: Group, group: Group) {\n    consumer.ul(classes = \"tree\") {\n      li {\n        span {\n          style = \"margin-right: 10px;\"\n          classes += \"glyphicon\"\n\n          if (group.children.isNotEmpty()) {\n            classes += \"glyphicon-folder-open\"\n/*\n            classes += if (group.opened) {\n              \"glyphicon-folder-open\"\n            } else {\n              \"glyphicon-folder-close\"\n            }\n*/\n          } else {\n            classes += \"glyphicon-folder-close\"\n            style = \"color: transparent;\"\n          }\n\n/*\n          onClickFunction = {\n              group.opened = !group.opened\n              refresh()\n          }\n*/\n        }\n        a {\n          href = \"#\"\n          var name = group.name\n\n          if (name.length > 14) {\n            name = name.slice(0..11) + \"...\"\n          }\n\n          +name\n\n          if (group.found) {\n            classes += \"found\"\n          }\n          if (group == UserState.currentGroup) {\n            classes += \"selected\"\n          }\n\n          onClickFunction = {\n            UserState.currentGroup = group\n            UserState.currentSearch = \"\"\n\n            container.update()\n          }\n\n        }\n        span(classes = \"badge\") {\n          +\"${group.passwords.size}/${group.getPasswordsCountInGroup()}\"\n        }\n        //if (group.opened) {\n          group.children.forEach {\n            createGroup(consumer, topGroup, it)\n          }\n        //}\n      }\n    }\n  }\n\n  override fun render(consumer: HtmlBuilder) = consumer.div(classes = \"col-md-3\") {\n    div(classes = \"row\") {\n      div(classes = \"col-md-12\") {\n        h4 {\n          +\"Password groups\"\n        }\n      }\n      val tg = topGroup\n\n      if (tg != null) {\n        createGroup(consumer, tg, tg)\n      }\n    }\n  }\n\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","package spm.view\n\nimport kotlinx.html.*\nimport kotlinx.html.js.div\nimport kotlinx.html.js.onClickFunction\nimport kotlinx.html.js.onInputFunction\nimport kotlinx.html.js.onKeyDownFunction\nimport nl.astraeus.komp.HtmlBuilder\nimport nl.astraeus.komp.Komponent\nimport org.w3c.dom.HTMLElement\nimport org.w3c.dom.HTMLInputElement\nimport org.w3c.dom.events.KeyboardEvent\nimport spm.state.UserState\nimport spm.util.Version\nimport spm.ws.WebSocketConnection\n\n/**\n * Created by rnentjes on 3-4-17.\n */\n\nenum class LoginTab {\n    LOGIN,\n    REGISTER\n}\n\nclass LoginForm(\n  var login: String = \"\",\n  var pwd1: String = \"\",\n  var pwd2: String = \"\"\n)\n\nclass Login : Komponent() {\n    var activeTab = LoginTab.LOGIN\n    var loginForm = LoginForm()\n\n    init {\n        style(\"version\") {\n            marginLeft = \"15px\"\n            fontSize = \"12px\"\n        }\n    }\n\n    fun login() {\n        if (loginForm.login.isBlank()) {\n            Modal.showAlert(\"Error\", \"Login name must be filled in!\")\n        } else if (loginForm.pwd1.isBlank()) {\n            Modal.showAlert(\"Error\", \"Password must be filled in!\")\n        } else {\n            UserState.loginname = loginForm.login\n\n            WebSocketConnection.loadingWork {\n                UserState.setPassword(loginForm.pwd1)\n\n                WebSocketConnection.send(\"LOGIN\",\n                  UserState.loginname ?: throw IllegalStateException(\"Whut!\"),\n                  UserState.loginPasswordHash ?: throw IllegalStateException(\"Whut!\")\n                )\n            }\n        }\n    }\n\n    fun register() {\n        if (loginForm.login.isBlank()) {\n            Modal.showAlert(\"Error\", \"Login name must be filled in!\")\n        } else if (loginForm.pwd1.isBlank()) {\n            Modal.showAlert(\"Error\", \"Password must be filled in!\")\n        } else if (loginForm.pwd1 != loginForm.pwd2) {\n            Modal.showAlert(\"Error\", \"Passwords must match!\")\n        } else {\n            UserState.loginname = loginForm.login\n\n            WebSocketConnection.loadingWork {\n                UserState.setPassword(loginForm.pwd1)\n\n                WebSocketConnection.send(\"REGISTER\",\n                  UserState.loginname ?: throw IllegalStateException(\"Whut!\"),\n                  UserState.loginPasswordHash ?: throw IllegalStateException(\"Whut!\"),\n                  UserState.createEncryptionKey()\n                )\n            }\n        }\n    }\n\n    override fun render(consumer: HtmlBuilder) = consumer.div(classes = \"container\") {\n        div(classes = \"row\") {\n            div(classes = \"col-md-6 col-md-offset-3\") {\n                h2 {\n                    style = \"text-align: center; margin-top: 40px;\"\n                    +\"Simple password manager\"\n                    span(classes = \"version\") {\n                        + Version.version\n                    }\n                }\n            }\n            div(classes = \"col-md-6 col-md-offset-3\") {\n                style = \"margin-top: 50px;\"\n                ul(classes = \"nav nav-tabs nav-justified\") {\n                    li {\n                        if (activeTab == LoginTab.LOGIN) {\n                            classes += \"active\"\n                        }\n                        role = \"presentation\"\n                        a {\n                            +\"Login\"\n                            onClickFunction = {\n                                activeTab = LoginTab.LOGIN\n\n                                update()\n                            }\n                        }\n                    }\n                    li {\n                        if (activeTab == LoginTab.REGISTER) {\n                            classes += \"active\"\n                        }\n                        role = \"presentation\"\n                        a {\n                            +\"Register\"\n                            onClickFunction = {\n                                activeTab = LoginTab.REGISTER\n\n                                update()\n                            }\n                        }\n                    }\n                }\n\n                div(classes = \"row\") { unsafe { +\"<span>&nbsp;</span>\" } }\n\n                if (activeTab == LoginTab.LOGIN) {\n                    div(classes = \"form-horizontal\") {\n                        div(classes = \"form-group\") {\n                            label(classes = \"col-md-4\") {\n                                for_ = \"login_name\"\n                                +\"Login name\"\n                            }\n                            div(classes = \"col-md-8\") {\n                                input(classes = \"form-control\") {\n                                    id = \"login_name\"\n                                    type = InputType.text\n                                    onInputFunction = { e ->\n                                        val target = e.target\n                                        if (target is HTMLInputElement) {\n                                            loginForm.login = target.value\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        div(classes = \"form-group\") {\n                            label(classes = \"col-md-4\") {\n                                for_ = \"login_password\"\n                                +\"Passphrase\"\n                            }\n                            div(classes = \"col-md-8\") {\n                                input(classes = \"form-control\") {\n                                    id = \"login_password\"\n                                    type = InputType.password\n                                    onInputFunction = { e ->\n                                        val target = e.target\n                                        if (target is HTMLInputElement) {\n                                            loginForm.pwd1 = target.value\n                                        }\n                                    }\n                                    onKeyDownFunction = { e ->\n                                        if (e is KeyboardEvent) {\n                                            if (e.keyCode == 13) {\n                                                login()\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        div(classes = \"form-group\") {\n                            div(classes = \"col-sm-offset-4 col-sm-8\") {\n                                a(classes = \"btn btn-success\") {\n                                    +\"Login\"\n                                    onClickFunction = {\n                                        login()\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    div(classes = \"form-horizontal\") {\n                        div(classes = \"form-group\") {\n                            label(classes = \"col-md-4\") {\n                                for_ = \"register_name\"\n                                +\"Login name\"\n                            }\n                            div(classes = \"col-md-8\") {\n                                input(classes = \"form-control\") {\n                                    id = \"register_name\"\n                                    type = InputType.text\n                                    onInputFunction = { e ->\n                                        val target = e.target\n                                        if (target is HTMLInputElement) {\n                                            loginForm.login = target.value\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        div(classes = \"form-group\") {\n                            label(classes = \"col-md-4\") {\n                                for_ = \"register_password\"\n                                +\"Passphrase\"\n                            }\n                            div(classes = \"col-md-8\") {\n                                input(classes = \"form-control\") {\n                                    id = \"register_password\"\n                                    type = InputType.password\n                                    onInputFunction = { e ->\n                                        val target = e.target\n                                        if (target is HTMLInputElement) {\n                                            loginForm.pwd1 = target.value\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        div(classes = \"form-group\") {\n                            label(classes = \"col-md-4\") {\n                                for_ = \"register_password2\"\n                                +\"Confirm passphrase\"\n                            }\n                            div(classes = \"col-md-8\") {\n                                input(classes = \"form-control\") {\n                                    id = \"register_password2\"\n                                    type = InputType.password\n                                    onInputFunction = { e ->\n                                        val target = e.target\n                                        if (target is HTMLInputElement) {\n                                            loginForm.pwd2 = target.value\n                                        }\n                                    }\n                                    onKeyDownFunction = { e ->\n                                        if (e is KeyboardEvent) {\n                                            if (e.keyCode == 13) {\n                                                register()\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        div(classes = \"col-md-offset-4 col-md-8\") {\n                            span(classes = \"help-block\") {\n                                style = \"color: red;\"\n                                +\"Please note that if you lose your passphrase there is no way to restore it. We don't know and we don't store your passphrase, so make sure you don't forget it!\"\n                            }\n                        }\n                        div(classes = \"form-group\") {\n                            div(classes = \"col-sm-offset-4 col-sm-8\") {\n                                a(classes = \"btn btn-warning\") {\n                                    +\"Register\"\n                                    onClickFunction = {\n                                        register()\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n}\n","package spm.view\n\nimport kotlinx.html.TagConsumer\nimport kotlinx.html.div\nimport kotlinx.html.js.div\nimport nl.astraeus.komp.HtmlBuilder\nimport nl.astraeus.komp.Komponent\nimport nl.astraeus.komp.include\nimport org.w3c.dom.HTMLElement\nimport org.w3c.dom.WebSocket\nimport spm.state.UserState\nimport spm.ws.CommandDispatcher\nimport spm.ws.Tokenizer\n\n/**\n * Created by rnentjes on 3-4-17.\n */\n\nclass Main : Komponent() {\n    val navbar = Navbar(this, this)\n\n    init {\n        CommandDispatcher.setLoginListener(this::login)\n    }\n\n    fun login(ws: WebSocket, tk: Tokenizer) {\n        UserState.encryptedEncryptionKey = tk.next()\n        UserState.loggedIn = true\n        UserState.loadData(tk.next())\n        UserState.readOnly = tk.next() == \"true\"\n\n        update()\n    }\n\n    override fun render(consumer: HtmlBuilder) = consumer.div {\n        if (!UserState.loggedIn) {\n            include(Login())\n        } else {\n            include(navbar)\n            include(Container(this@Main))\n        }\n    }\n\n}\n","package spm.view\n\nimport kotlinx.html.ButtonType\nimport kotlinx.html.TagConsumer\nimport kotlinx.html.button\nimport kotlinx.html.div\nimport kotlinx.html.h4\nimport kotlinx.html.id\nimport kotlinx.html.js.div\nimport kotlinx.html.js.onClickFunction\nimport kotlinx.html.role\nimport kotlinx.html.span\nimport kotlinx.html.tabIndex\nimport nl.astraeus.komp.HtmlBuilder\nimport nl.astraeus.komp.Komponent\nimport nl.astraeus.komp.include\nimport org.w3c.dom.HTMLElement\nimport kotlin.browser.document\n\n/**\n * Created by rnentjes on 30-3-17.\n */\n\nclass ModalComponent(\n  val modalId: String,\n  val modalTitle: String,\n  val body: Komponent,\n  val okText: String = \"Ok\",\n  val cancelText: String = \"Cancel\",\n  val okButtonClass: String = \"btn-primary\",\n  val modalSize: String = \"\",\n  val showCancel: Boolean = true,\n  val disabledOk: Boolean = false,\n  var ok: () -> Unit = {},\n  var cancel: () -> Unit = {}) : Komponent() {\n\n    override fun render(consumer: HtmlBuilder) = consumer.div(classes = \"modal fade\") {\n        attributes[\"data-backkdrop\"] = \"true\"\n        id = modalId\n        tabIndex = \"1\"\n        role = \"dialog\"\n        div(classes = \"modal-dialog $modalSize\") {\n            role = \"document\"\n            div(classes = \"modal-content\") {\n                div(classes = \"modal-header\") {\n                    button(classes = \"close\") {\n                        type = ButtonType.button\n                        attributes[\"data-dismiss\"] = \"modal\"\n                        attributes[\"aria-label\"] = \"Close\"\n                        span {\n                            attributes[\"aria-hidden\"] = \"true\"\n                            +\"\u00d7\"\n                        }\n                        onClickFunction = {\n                            cancel()\n                        }\n                    }\n                    h4(classes = \"modal-title\") { + modalTitle }\n                }\n                div(classes = \"modal-body\") {\n                    include(body)\n                }\n                div(classes = \"modal-footer\") {\n                    if (showCancel) {\n                        button(classes = \"btn btn-default\") {\n                            type = ButtonType.button\n                            attributes[\"data-dismiss\"] = \"modal\"\n                            +cancelText\n                            onClickFunction = { e ->\n                                e.preventDefault()\n\n                                cancel()\n                            }\n                        }\n                    }\n                    button(classes = \"btn $okButtonClass\") {\n                        type = ButtonType.button\n                        +okText\n                        disabled = disabledOk\n                        onClickFunction = { e ->\n                            e.preventDefault()\n\n                            ok()\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nclass AlertComponent(val message: String): Komponent() {\n\n    override fun render(consumer: HtmlBuilder) = consumer.div {\n        println(\"render AlertComponent $message\")\n        span {\n            + message\n        }\n    }\n\n}\n\nobject Modal {\n    var id = 0\n\n    fun nextId() = \"modal_${++id}\"\n\n    fun openModal(\n      title: String,\n      body: Komponent,\n      okText: String = \"Ok\",\n      cancelText: String = \"Cancel\",\n      modalSize: String = \"\",\n      okButtonClass: String = \"btn-primary\",\n      showCancel: Boolean = false,\n      disabledOk: Boolean = false,\n      ok: () -> Boolean,\n      cancel: () -> Unit = {}\n    ): String {\n        val id = nextId()\n        val modal = ModalComponent(\n          id,\n          title,\n          body,\n          okText = okText,\n          cancelText = cancelText,\n          modalSize = modalSize,\n          okButtonClass = okButtonClass,\n          showCancel = showCancel,\n          disabledOk = disabledOk,\n          cancel = cancel\n        )\n\n        modal.ok = {\n            if (ok()) {\n                hideModal(id)\n            }\n        }\n\n        Komponent.create(document.body ?: throw IllegalStateException(\"Document.body not found!\"), modal)\n\n        attachHideEvent(id, modal)\n\n        showModal(id)\n\n        return id\n    }\n\n    fun showAlert(title: String, message: String, buttonText: String = \"Close\") {\n        openModal(title, AlertComponent(message), showCancel = false, okText = buttonText, ok = { true })\n    }\n\n    fun showConfirm(\n      title: String,\n      body: Komponent,\n      confirmText: String = \"Yes\",\n      denyText: String = \"No\",\n      showCancel: Boolean = false,\n      disabledConfirm: Boolean = false,\n      confirm: () -> Boolean = { true }\n    ) {\n        openModal(title, body, okText = confirmText, cancelText = denyText, disabledOk = disabledConfirm, ok = { confirm(); }, showCancel = showCancel)\n    }\n\n    private fun attachHideEvent(id: String, komponent: Komponent) {\n        js(\"\"\"\n            $('#' + id).on('hidden.bs.modal', function (event) {\n                komponent.remove()\n            })\n        \"\"\")\n    }\n\n    fun hideModal(id: String) = js(\"$('#' + id).modal('hide')\")\n\n    fun showModal(id: String) = js(\"$('#' + id).modal({ backdrop: 'static', keyboard: false })\")\n}\n","package spm.view\n\nimport kotlinx.html.*\nimport kotlinx.html.js.nav\nimport kotlinx.html.js.onClickFunction\nimport kotlinx.html.js.onKeyUpFunction\nimport kotlinx.html.js.onSubmitFunction\nimport nl.astraeus.komp.HtmlBuilder\nimport nl.astraeus.komp.Komponent\nimport org.w3c.dom.HTMLElement\nimport org.w3c.dom.HTMLInputElement\nimport org.w3c.dom.events.Event\nimport spm.state.UserState\nimport spm.util.Version\nimport spm.view.Modal\n\n/**\n * Created by rnentjes on 3-4-17.\n */\nclass Navbar(val main: Komponent, val container: Komponent): Komponent() {\n    var search = UserState.currentSearch\n\n    init {\n        style(\"version\") {\n            marginLeft = \"15px\"\n            fontSize = \"12px\"\n        }\n    }\n\n    fun searchPasswords(e: Event) {\n        e.preventDefault()\n\n        UserState.currentSearch = search\n        UserState.currentGroup = null\n\n        container.update()\n    }\n\n    fun logout(e: Event) {\n        UserState.logout()\n\n        main.update()\n    }\n\n    fun settings(e: Event) {\n        val changePassword = ChangePassword()\n\n        Modal.openModal(\n          \"Change passphrase\",\n          changePassword,\n          okText = \"Update passphrase\",\n          showCancel = true,\n          ok = {\n              UserState.updatePassword(\n                changePassword.currentPassword,\n                changePassword.newPassword1,\n                changePassword.newPassword2\n              )\n\n              true\n          })\n    }\n\n    override fun render(consumer: HtmlBuilder) = consumer.nav(classes=\"navbar navbar-default navbar-static-top\") {\n        div(classes = \"container-fluid\") {\n            if (UserState.obtainedLock) {\n                style = \"background-color: #ffabab\"\n            } else if (UserState.readOnly) {\n                style = \"background-color: #fffdab\"\n            }\n            div(classes = \"navbar-header\") {\n                button(classes = \"navbar-toggle collapsed\") {\n                    attributes.put(\"data-toggle\", \"collapse\")\n                    attributes.put(\"data-target\", \"#bs-example-navbar-collapse-1\")\n                    attributes.put(\"aria-expanded\", \"false\")\n\n                    span(classes = \"sr-only\") { + \"Toggle navigation\" }\n                    span(classes = \"icon-bar\")\n                    span(classes = \"icon-bar\")\n                    span(classes = \"icon-bar\")\n                }\n                a(classes = \"navbar-brand\") {\n                    href = \"#\"\n                    if (UserState.readOnly) {\n                        +\"Simple password manager (read only)\"\n                    } else {\n                        +\"Simple password manager\"\n                    }\n                    span(classes = \"version\") {\n                        + Version.version\n                    }\n                }\n            }\n\n            div(classes = \"collapse navbar-collapse\") {\n                id = \"bs-example-navbar-collapse-1\"\n                ul(classes = \"nav navbar-nav navbar-right\") {\n                    li {\n                        a {\n                            href = \"#\"\n                            style = \"font-size: large;\"\n                            span(classes = \"glyphicon glyphicon-cog\")\n\n                            onClickFunction = this@Navbar::settings\n                        }\n                    }\n\n                    li {\n                        a {\n                            href = \"#\"\n                            style = \"font-size: large;\"\n                            span(classes = \"glyphicon glyphicon-off\")\n\n                            onClickFunction = this@Navbar::logout\n                        }\n                    }\n                }\n                form(classes = \"navbar-form navbar-right\") {\n\n\n                    onSubmitFunction = this@Navbar::searchPasswords\n\n                    div(classes = \"form-group\") {\n                        input(classes = \"form-control\") {\n                            type = InputType.text\n                            placeholder = \"Search\"\n                            value = search\n\n                            onKeyUpFunction = { e ->\n                                search = (e.target as HTMLInputElement).value\n                            }\n                        }\n                    }\n                    button(classes = \"btn btn-default\") {\n                        type = ButtonType.button\n                        + \"Search\"\n\n\n                        onClickFunction = this@Navbar::searchPasswords\n                    }\n                }\n            }\n        }\n    }\n\n\n}\n","package spm.view\n\n/**\n * User: rnentjes\n * Date: 22-4-17\n * Time: 15:00\n */\n\nobject Notify {\n\n    /**\n     * type:\n     * - success\n     * - info\n     * - warning\n     * - error\n     */\n    fun show(message: String, type: String = \"\") {\n        js(\"$.notify(message, type)\")\n    }\n\n}\n","package spm.view\n\nimport kotlinx.html.*\nimport kotlinx.html.js.onBlurFunction\nimport kotlinx.html.js.onClickFunction\nimport kotlinx.html.js.onKeyUpFunction\nimport nl.astraeus.komp.HtmlBuilder\nimport nl.astraeus.komp.Komponent\nimport nl.astraeus.komp.include\nimport org.w3c.dom.HTMLElement\nimport org.w3c.dom.HTMLInputElement\nimport org.w3c.dom.HTMLSelectElement\nimport org.w3c.dom.HTMLTextAreaElement\nimport org.w3c.dom.events.Event\nimport spm.model.Group\nimport spm.model.HistoryEntry\nimport spm.model.Password\nimport spm.state.UserState\nimport spm.util.copyToClipboard\nimport spm.view.button.PasswordButton\nimport spm.view.input.SelectInput\nimport spm.view.input.TextInput\nimport spm.view.Modal\n\n/**\n * User: rnentjes\n * Date: 5-4-17\n * Time: 9:46\n */\n\nclass RemoveHistoryEntryConfirm(val history: HistoryEntry) : Komponent() {\n    override fun render(consumer: HtmlBuilder) = consumer.span {\n        +\"Are you sure you want to remove the history entry from '${history.from}' until '${history.until}?\"\n    }\n}\n\nclass ClearHistoryConfirm : Komponent() {\n    override fun render(consumer: HtmlBuilder) = consumer.span {\n        +\"Are you sure you want to clear the history for this password?\"\n    }\n}\n\nclass PasswordEditor(val group: Group, val originalPassword: Password? = null) : Komponent() {\n    val password: Password\n    var showPassword = false\n\n    init {\n        if (originalPassword != null) {\n            password = Password(originalPassword)\n\n            password.decrypt()\n        } else {\n            password = Password(group)\n        }\n\n        style(\"nowrap\", Styles.nowrap)\n    }\n\n    fun validate(): Boolean {\n        return true\n    }\n\n    private fun updateGroup(e: Event) {\n        val target = e.target\n\n        if (target is HTMLSelectElement) {\n            val group = UserState.topGroup?.findById(target.value.toLong()) ?:\n              throw IllegalStateException(\"Group with id ${target.value} not found!\")\n\n            password.group = group\n        }\n    }\n\n    override fun render(consumer: HtmlBuilder) = consumer.div(classes = \"col-md-12\") {\n        val pwType = if (showPassword) {\n            InputType.text\n        } else {\n            InputType.password\n        }\n\n        form(classes = \"form form-horizontal\") {\n\n            include(SelectInput(\n              \"password_group\",\n              label = \"Group\",\n              inputValue = \"${password.group.id}\",\n              options = UserState.topGroup?.getGroups() ?: ArrayList(),\n              readOnly = UserState.readOnly,\n              change = this@PasswordEditor::updateGroup\n            ))\n\n            include(TextInput(\"password_title\", \"Title\", password.title,\n              readOnly = UserState.readOnly,\n              blur = { e ->\n                  password.title = (e.target as HTMLInputElement).value\n              },\n              change = { e ->\n                  password.title = (e.target as HTMLInputElement).value\n              }))\n\n            include(TextInput(\"password_url\", \"Url\", password.website,\n              readOnly = UserState.readOnly,\n              blur = { e ->\n                  password.website = (e.target as HTMLInputElement).value\n              },\n              change = { e ->\n                  password.website = (e.target as HTMLInputElement).value\n              }))\n            include(TextInput(\"password_username\", \"Username\", password.username,\n              readOnly = UserState.readOnly,\n              blur = { e ->\n                  password.username = (e.target as HTMLInputElement).value\n              },\n              change = { e ->\n                  password.username = (e.target as HTMLInputElement).value\n              }))\n            div(classes = \"form-group\") {\n                //                if (error.isNotBlank()) {\n//                    classes += \"has-error\"\n//                }\n                label(classes = \"col-md-3\") {\n                    for_ = \"password_password1\"\n                    +\"Password\"\n                }\n                div(classes = \"col-md-7\") {\n                    input(classes = \"form-control\") {\n                        id = \"password_password1\"\n                        name = \"password_password1\"\n                        type = pwType\n                        value = password.password1\n                        readonly = UserState.readOnly\n\n                        fun changePwd1(e: Event) {\n                            password.password1 = (e.target as HTMLInputElement).value\n                        }\n\n                        onBlurFunction = ::changePwd1\n                        onKeyUpFunction = ::changePwd1\n                    }\n//                    if (error.isNotBlank()) {\n//                        span(classes = \"help-block\") {\n//                            +error\n//                        }\n//                    }\n                }\n\n                div(classes = \"col-md-2\") {\n                    button(classes = \"btn btn-default\") {\n                        type = ButtonType.button\n                        attributes[\"aria-label\"] = \"Show\"\n                        if (showPassword) {\n                            span(classes = \"glyphicon glyphicon-eye-open\") {\n                                attributes[\"aria-hidden\"] = \"true\"\n                            }\n                            onClickFunction = { e ->\n                                e.preventDefault()\n\n                                showPassword = !showPassword\n\n                                update()\n                            }\n                        } else {\n                            span(classes = \"glyphicon glyphicon-eye-close\") {\n                                attributes[\"aria-hidden\"] = \"true\"\n                            }\n                            onClickFunction = { e ->\n                                e.preventDefault()\n\n                                showPassword = !showPassword\n\n                                update()\n                            }\n                        }\n                    }\n                }\n            }\n            div(classes = \"form-group\") {\n                //                if (error.isNotBlank()) {\n//                    classes += \"has-error\"\n//                }\n                label(classes = \"col-md-3\") {\n                    for_ = \"password_password2\"\n                    +\"Confirm password\"\n                }\n                div(classes = \"col-md-7\") {\n                    input(classes = \"form-control\") {\n                        id = \"password_password2\"\n                        name = \"password_password2\"\n                        type = pwType\n                        value = password.password2\n                        readonly = UserState.readOnly\n\n                        fun changePwd2(e: Event) {\n                            password.password2 = (e.target as HTMLInputElement).value\n                        }\n\n                        onBlurFunction = ::changePwd2\n                        onKeyUpFunction = ::changePwd2\n                    }\n//                    if (error.isNotBlank()) {\n//                        span(classes = \"help-block\") {\n//                            +error\n//                        }\n//                    }\n                }\n\n                div(classes = \"col-md-2\") {\n                    if (!UserState.readOnly) {\n                        button(classes = \"btn btn-default\") {\n                            type = ButtonType.button\n                            attributes[\"aria-label\"] = \"Show\"\n                            span(classes = \"glyphicon glyphicon-cog\") {\n                                attributes[\"aria-hidden\"] = \"true\"\n                            }\n                            onClickFunction = { e ->\n                                e.preventDefault()\n\n                                val generator = PasswordGenerator(password)\n\n                                Modal.openModal(\"Generate password\", generator, ok = {\n                                    password.password1 = generator.generatedPassword\n                                    password.password2 = generator.generatedPassword\n\n                                    update()\n                                    true\n                                })\n                            }\n                        }\n                    }\n                }\n            }\n            div(classes = \"form-group\") {\n                //                if (error.isNotBlank()) {\n//                    classes += \"has-error\"\n//                }\n                label(classes = \"col-md-3\") {\n                    for_ = \"password_notes\"\n                    +\"Notes\"\n                }\n                div(classes = \"col-md-9\") {\n                    textArea(classes = \"form-control\") {\n                        id = \"password_notes\"\n                        rows = \"4\"\n                        readonly = UserState.readOnly\n\n                        +password.description\n                    }\n//                    if (error.isNotBlank()) {\n//                        span(classes = \"help-block\") {\n//                            +error\n//                        }\n//                    }\n                }\n\n                fun updateNotes(e: Event) {\n                    password.description = (e.target as HTMLTextAreaElement).value\n                }\n\n                onBlurFunction = ::updateNotes\n                onKeyUpFunction = ::updateNotes\n            }\n        }\n\n        if (originalPassword?.hasHistory() == true) {\n            div(classes = \"row\") {\n                div(classes = \"col-md-10\") {\n                    h5 {\n                        +\"Password history\"\n                    }\n                }\n                div(classes = \"col-md-2\") {\n                    if (!UserState.readOnly) {\n                        button(classes = \"btn btn-danger btn-xs\") {\n                            type = ButtonType.button\n                            attributes[\"aria-label\"] = \"Clear history\"\n                            title = \"Clear password history\"\n\n                            +\"Clear\"\n\n                            onClickFunction = {\n                                Modal.openModal(\"Remove password\",\n                                                ClearHistoryConfirm(),\n                                                okButtonClass = \"btn-danger\",\n                                                ok = {\n                                                    originalPassword.history.clear()\n                                                    UserState.saveData()\n                                                    update()\n\n                                                    true\n                                                })\n                            }\n                        }\n                    }\n                }\n            }\n            div(classes = \"row\") {\n                table(classes = \"table table-striped table-condensed table-hover\") {\n                    tr {\n                        th { +\"Password\" }\n                        th { +\"From\" }\n                        th { +\"Until\" }\n                        th { +\"\" }\n                    }\n                    for (history in originalPassword.history) {\n                        tr {\n                            td(classes = \"col-md-4\") {\n                                + \"********\"\n                            }\n                            td(classes = \"col-md-3 nowrap\") {\n                                + history.from\n                            }\n                            td(classes = \"col-md-3 nowrap\") {\n                                + history.until\n                            }\n                            td(classes = \"col-md-2 nowrap\") {\n                                include(PasswordButton(\n                                  \"copy\",\n                                  text = \"P \",\n                                  tooltip = \"Copy password\",\n                                  btnClass = \"btn-xs btn-warning\",\n                                  buttonStyle = \"margin-left: 5px;\"\n                                ) {\n                                    copyToClipboard(\n                                      UserState.decryptPassword(history.encryptedPassword),\n                                      this@PasswordEditor.element as HTMLElement\n                                    )\n\n                                    Notify.show(\"Copied password to clipboard.\", \"success\")\n                                })\n                                if (!UserState.readOnly) {\n                                    include(PasswordButton(\n                                        \"remove\",\n                                        tooltip = \"Remove history entry\",\n                                        btnClass = \"btn-xs btn-danger\",\n                                        buttonStyle = \"margin-left: 5px;\"\n                                    ) {\n                                        Modal.openModal(\"Remove password\",\n                                                        RemoveHistoryEntryConfirm(history),\n                                                        okButtonClass = \"btn-danger\",\n                                                        ok = {\n                                                            originalPassword.history.remove(history)\n                                                            UserState.saveData()\n                                                            update()\n\n                                                            true\n                                                        })\n                                    })\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n}\n","package spm.view\n\nimport kotlinx.html.*\nimport kotlinx.html.js.onBlurFunction\nimport kotlinx.html.js.onClickFunction\nimport kotlinx.html.js.onKeyUpFunction\nimport nl.astraeus.komp.HtmlBuilder\nimport nl.astraeus.komp.Komponent\nimport org.w3c.dom.HTMLInputElement\nimport org.w3c.dom.events.Event\nimport spm.model.Password\nimport spm.state.UserState\nimport kotlin.js.Math\n\n/**\n * User: rnentjes\n * Date: 5-4-17\n * Time: 9:46\n */\n\nprivate val basic = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nprivate val numbers = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\nprivate val special = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ~`!@#$%*()_+-={}[]:\\\"|;'\\\\<>?,./\"\nprivate val specialNumbers = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ~`!@#$%*()_+-={}[]:\\\"|;'\\\\<>?,./0123456789\"\n\nclass PasswordGenerator(val password: Password) : Komponent() {\n  var passwordLength = 26\n  var includeNumbers = true\n  var includeSpecial = true\n  var generatedPassword = UserState.decryptPassword(password.encryptedPassword)\n\n  override fun render(consumer: HtmlBuilder) = consumer.div(classes = \"col-md-12\") {\n    form(classes = \"form form-horizontal\") {\n      div(classes = \"form-group\") {\n        label(classes = \"col-md-3\") {\n          for_ = \"password_length\"\n          +\"Password length\"\n        }\n        div(classes = \"col-md-9\") {\n          input(classes = \"form-control\") {\n            id = \"password_length\"\n            value = passwordLength.toString()\n\n            fun changeLength(e: Event) {\n              passwordLength = (e.target as HTMLInputElement).value.toInt()\n            }\n\n            onBlurFunction = ::changeLength\n            onKeyUpFunction = ::changeLength\n          }\n        }\n      }\n      div(classes = \"form-group\") {\n        div(classes = \"col-md-offset-3 col-md-9\") {\n          div(classes = \"checkbox\") {\n            label {\n              htmlFor = \"password_numbers\"\n              input {\n                id = \"password_numbers\"\n                type = InputType.checkBox\n                checked = includeNumbers\n\n                onClickFunction = {\n                  includeNumbers = !includeNumbers\n                }\n              }\n              +\"Numbers '0..9'\"\n            }\n\n          }\n        }\n      }\n      div(classes = \"form-group\") {\n        div(classes = \"col-md-offset-3 col-md-9\") {\n          div(classes = \"checkbox\") {\n            label {\n              for_ = \"password_special\"\n              input {\n                id = \"password_special\"\n                type = InputType.checkBox\n                checked = includeSpecial\n\n                onClickFunction = {\n                  includeSpecial = !includeSpecial\n                }\n              }\n              +\"Special '!@#$'<`~' etc\"\n            }\n\n          }\n        }\n      }\n      div(classes = \"form-group\") {\n        label(classes = \"col-md-3\") {\n          for_ = \"password_generated\"\n          +\"Generated pwd\"\n        }\n        div(classes = \"col-md-7\") {\n          input(classes = \"form-control\") {\n            id = \"password_generated\"\n            value = generatedPassword\n          }\n        }\n\n        div(classes = \"col-md-2\") {\n          button(classes = \"btn btn-default\") {\n            type = ButtonType.button\n            attributes[\"aria-label\"] = \"Refresh\"\n            span(classes = \"glyphicon glyphicon-refresh\") {\n              attributes[\"aria-hidden\"] = \"true\"\n            }\n            onClickFunction = { e ->\n              e.preventDefault()\n\n              generatedPassword = generatePassword(passwordLength, includeNumbers, includeSpecial)\n\n              update()\n            }\n          }\n        }\n      }\n    }\n  }\n\n  private fun generatePassword(length: Int, includeNumbers: Boolean, includeSpecial: Boolean): String {\n    val builder = StringBuilder()\n    val source: String\n    var select = 0\n\n    if (includeNumbers) {\n      select += 1\n    }\n    if (includeSpecial) {\n      select += 2\n    }\n\n    source = when (select) {\n      0    -> {\n        basic\n      }\n      1    -> {\n        numbers\n      }\n      2    -> {\n        special\n      }\n      3    -> {\n        specialNumbers\n      }\n      else -> {\n        specialNumbers\n      }\n    }\n\n    for (index in 0 until length) {\n      builder.append(source[(source.length * Math.random()).toInt()])\n    }\n\n    return builder.toString()\n  }\n\n}\n","package spm.view\n\nimport kotlinx.html.*\nimport kotlinx.html.js.div\nimport kotlinx.html.js.onBlurFunction\nimport kotlinx.html.js.onClickFunction\nimport kotlinx.html.js.onKeyUpFunction\nimport nl.astraeus.komp.HtmlBuilder\nimport nl.astraeus.komp.Komponent\nimport nl.astraeus.komp.include\nimport org.w3c.dom.HTMLInputElement\nimport org.w3c.dom.HTMLTextAreaElement\nimport org.w3c.dom.events.Event\nimport spm.model.Group\nimport spm.model.Password\nimport spm.state.UserState\nimport spm.view.table.Table\nimport spm.ws.WebSocketConnection\nimport kotlin.browser.document\n\n/**\n * Created by rnentjes on 4-4-17.\n */\n\nclass RemovePasswordConfirm(val password: Password) : Komponent() {\n  override fun render(consumer: HtmlBuilder) = consumer.span {\n    +\"Are you sure you want to remove password '${password.title}'?\"\n  }\n}\n\nclass RemoveGroupConfirm(val groupName: String) : Komponent() {\n  override fun render(consumer: HtmlBuilder) = consumer.span {\n    +\"Are you sure you want to remove group '$groupName'?\"\n  }\n}\n\nclass GroupNameEdit(var groupname: String = \"\") : Komponent() {\n\n  override fun render(consumer: HtmlBuilder) = consumer.div(classes = \"\") {\n    form(classes = \"form form-horizontal\") {\n      div(classes = \"form-group\") {\n        label(classes = \"col-md-3\") {\n          for_ = \"groupname\"\n          +\"Group name\"\n        }\n        div(classes = \"col-md-9\") {\n          input(classes = \"form-control\") {\n            id = \"groupname\"\n            value = groupname\n\n            fun changeName(e: Event) {\n              e.preventDefault()\n\n              groupname = (e.target as HTMLInputElement).value\n            }\n\n            onBlurFunction = ::changeName\n            onKeyUpFunction = ::changeName\n          }\n        }\n      }\n\n    }\n  }\n}\n\nclass PasswordOverview(val container: Komponent) : Komponent() {\n\n  fun addPassword(cg: Group) {\n\n    WebSocketConnection.lock { ws, tk ->\n      val response = tk.next()\n\n      if (response == \"LOCKED\") {\n        val editor = PasswordEditor(cg)\n        editor.password.group = cg\n        Modal.openModal(\n            \"Edit password\",\n            editor,\n            okText = \"Save\",\n            okButtonClass = \"btn-success\",\n            ok = {\n              if (editor.validate()) {\n                if (editor.originalPassword == null) {\n                  editor.password.encryptedPassword = UserState.encryptPassword(editor.password.password1)\n                  editor.password.group.passwords.add(editor.password)\n                } else {\n                  throw IllegalStateException(\"Add button modal has existing password!?\")\n                }\n                UserState.saveData()\n                container.update()\n\n                true\n              } else {\n\n                false\n              }\n            },\n            cancel = {\n              ws.send(\"UNLOCK\")\n            }\n        )\n      } else {\n        Modal.showAlert(\"Blocked\", \"Unable to obtain modify lock.\")\n      }\n    }\n  }\n\n  override fun render(consumer: HtmlBuilder) = consumer.div(classes = \"col-md-9\") {\n    val cg = UserState.currentGroup\n    //console.log(\"Currentgroup: \", cg)\n    if (cg != null) {\n      div(classes = \"row\") {\n        div(classes = \"col-md-6\") {\n          h3 {\n            // background-color: #f8f8f8;\n            style = \"text-align: center; padding: 10px; margin: 5px\"\n            val group = UserState.currentGroup\n            if (group != null) {\n              +group.name\n            }\n          }\n        }\n\n        if (!UserState.readOnly) {\n          include(GroupCommands(cg, container))\n        }\n      }\n      hr {}\n      div {\n        //id = \"passwords_overview\"\n        div(classes = \"page-header\") {\n          div(classes = \"btn-toolbar pull-right\") {\n            div(classes = \"button-group\") {\n              if (!UserState.readOnly) {\n                a(classes = \"btn btn-success btn-sm\") {\n                  +\"Add\"\n                  onClickFunction = {\n                    this@PasswordOverview.addPassword(cg)\n                  }\n                }\n              }\n            }\n          }\n          h4 {\n            +\"Passwords\"\n          }\n        }\n        div(classes = \"row\") {\n          div(classes = \"col-md-12\") {\n            passwordTable(cg.passwords, container)\n          }\n        }\n      }\n    }\n  }\n\n  fun copyToClipboard(text: String) {\n    val ta = document.createElement(\"textarea\")\n    ta.innerHTML = text\n\n    if (ta is HTMLTextAreaElement) {\n      val body = document.body ?: throw IllegalStateException(\"The body was not found!\")\n\n      body.appendChild(ta)\n      ta.select()\n      document.execCommand(\"copy\")\n      body.removeChild(ta)\n    }\n  }\n}\n","package spm.view\n\nimport kotlinx.html.Tag\nimport kotlinx.html.td\nimport kotlinx.html.tr\nimport nl.astraeus.komp.HtmlBuilder\nimport nl.astraeus.komp.Komponent\nimport nl.astraeus.komp.include\nimport spm.model.Password\nimport spm.state.UserState\nimport spm.util.copyToClipboard\nimport spm.util.formatted\nimport spm.util.trimmed\nimport spm.view.button.PasswordButton\nimport spm.view.table.Table\nimport spm.ws.WebSocketConnection\nimport kotlin.browser.window\nimport kotlin.js.Date\n\n/**\n * User: rnentjes\n * Date: 11-10-17\n * Time: 16:48\n */\n\n\nfun Tag.passwordTable(\n    passwords: List<Password>,\n    container: Komponent,\n    showGroup: Boolean = false\n) {\n  include(Table(\n      if (showGroup) {\n        arrayOf(\n            \"Group\",\n            \"Title\",\n            \"Url\",\n            \"Username\",\n            \"Hist\",\n            \"\"\n        )\n      } else {\n        arrayOf(\n            \"Title\",\n            \"Url\",\n            \"Username\",\n            \"Hist\",\n            \"\"\n        )\n      },\n      passwords\n  ) { password ->\n    include(PasswordOverviewRow(password, container, showGroup))\n  })\n}\n\nclass PasswordOverviewRow(\n    val password: Password,\n    val container: Komponent,\n    val showGroup: Boolean = false\n) : Komponent() {\n\n  init {\n    style(\"nowrap\", Styles.nowrap)\n  }\n\n  private fun editPassword(password: Password) {\n    if (UserState.readOnly) {\n      openEditPasswordModal(password)\n    } else {\n      WebSocketConnection.lock { ws, tk ->\n        val response = tk.next()\n\n        if (response == \"LOCKED\") {\n          openEditPasswordModal(password, true)\n        } else {\n          Modal.showAlert(\"Blocked\", \"Unable to obtain modify lock.\")\n        }\n      }\n    }\n  }\n\n  private fun openEditPasswordModal(password: Password, locked: Boolean = false) {\n    val editor = PasswordEditor(password.group, password)\n\n    fun okCallback(): Boolean = if (!UserState.readOnly) {\n      if (editor.validate()) {\n        if (editor.originalPassword != null) {\n          editor.originalPassword.title = editor.password.title\n          editor.originalPassword.website = editor.password.website\n          editor.originalPassword.username = editor.password.username\n          editor.originalPassword.description = editor.password.description\n\n          val originalGroup = editor.originalPassword.group\n          val newGroup = editor.password.group\n\n          if (originalGroup != newGroup) {\n            originalGroup.passwords.remove(editor.originalPassword)\n            newGroup.passwords.add(editor.originalPassword)\n            editor.originalPassword.group = editor.password.group\n          }\n\n          if (editor.password.password1.isNotBlank()) {\n            val oldPassword = UserState.decryptPassword(\n                editor.originalPassword.encryptedPassword\n            )\n            if (oldPassword != editor.password.password1) {\n              editor.originalPassword.archivePassword()\n              editor.originalPassword.encryptedPassword = UserState.encryptPassword(\n                  editor.password.password1\n              )\n              editor.originalPassword.created = Date().formatted()\n            }\n          }\n        } else {\n          throw IllegalStateException(\"Edit button doesn't have original password!?\")\n        }\n\n        if (locked) {\n          UserState.saveData()\n          container.update()\n        }\n\n        true\n      } else {\n        false\n      }\n    } else {\n      true\n    }\n\n    Modal.openModal(\n        \"Edit password\",\n        editor,\n        /*modalSize = \"modal-lg\", */\n        ok = {\n          okCallback()\n        },\n        cancel = if (locked) {\n          { WebSocketConnection.send(\"UNLOCK\") }\n        } else {\n          {}\n        }\n    )\n  }\n\n  private fun removePassword(password: Password) {\n    WebSocketConnection.lock { ws, tk ->\n      val response = tk.next()\n\n      if (response == \"LOCKED\") {\n        Modal.openModal(\n            \"Remove password\",\n            RemovePasswordConfirm(password),\n            okButtonClass = \"btn-danger\",\n            ok = {\n              password.delete()\n              UserState.saveData()\n              container.update()\n\n              true\n            },\n            cancel = {\n              ws.send(\"UNLOCK\")\n            }\n        )\n      } else {\n        Modal.showAlert(\"Blocked\", \"Unable to obtain modify lock.\")\n      }\n    }\n  }\n\n  private fun removeHistory(password: Password) {\n    WebSocketConnection.lock { ws, tk ->\n      val response = tk.next()\n\n      if (response == \"LOCKED\") {\n        Modal.openModal(\n            \"Remove password\",\n            ClearHistoryConfirm(),\n            okButtonClass = \"btn-danger\",\n            ok = {\n              password.history.clear()\n              UserState.saveData()\n              update()\n\n              true\n            },\n            cancel = {\n              ws.send(\"UNLOCK\")\n            }\n        )\n      } else {\n        Modal.showAlert(\"Blocked\", \"Unable to obtain modify lock.\")\n      }\n    }\n  }\n\n  override fun render(consumer: HtmlBuilder) = consumer.tr {\n\n    if (showGroup) {\n      trimmed(password.group.name, 8)\n    }\n    trimmed(password.title, 12)\n    trimmed(password.website, 24)\n    trimmed(password.username, 12)\n\n    td {\n      if (password.history.isNotEmpty()) {\n        include(PasswordButton(\n            \"\",\n            text = \"${password.history.size} \",\n            tooltip = \"Clear history\",\n            btnClass = \"btn-xs btn-danger\"\n        ) {\n          removeHistory(password)\n        })\n      }\n    }\n    td(classes = \"col-md-4 nowrap\") {\n      include(PasswordButton(\n          \"copy\",\n          text = \"U \",\n          tooltip = \"Copy username\",\n          btnClass = \"btn-xs btn-default\"\n      ) {\n        copyToClipboard(password.username)\n\n        Notify.show(\"Copied username to clipboard.\", \"success\")\n      })\n      include(PasswordButton(\n          \"copy\",\n          text = \"P \",\n          tooltip = \"Copy password\",\n          btnClass = \"btn-xs btn-warning\",\n          buttonStyle = \"margin-left: 5px;\"\n      ) {\n        copyToClipboard(UserState.decryptPassword(password.encryptedPassword))\n\n        Notify.show(\"Copied password to clipboard.\", \"success\")\n      })\n      include(PasswordButton(\n          \"copy\",\n          text = \"U \",\n          tooltip = \"Copy url\",\n          btnClass = \"btn-xs btn-default\",\n          buttonStyle = \"margin-left: 5px;\"\n      ) {\n        copyToClipboard(password.website)\n\n        Notify.show(\"Copied password to clipboard.\", \"success\")\n      })\n      include(PasswordButton(\n          \"new-window\",\n          text = \"U \",\n          tooltip = \"Open url in a new window\",\n          btnClass = \"btn-xs btn-default\",\n          buttonStyle = \"margin-left: 5px;\"\n      ) {\n        window.open(password.website, \"_blank\")\n      })\n      include(PasswordButton(\n          \"folder-open\",\n          tooltip = \"Edit password entry\",\n          btnClass = \"btn-xs btn-success\",\n          buttonStyle = \"margin-left: 5px;\"\n      ) {\n        editPassword(password)\n      })\n      if (!UserState.readOnly) {\n        include(PasswordButton(\n            \"remove\",\n            tooltip = \"Remove password entry\",\n            btnClass = \"btn-xs btn-danger\",\n            buttonStyle = \"margin-left: 5px;\"\n        ) {\n          removePassword(password)\n        })\n      }\n    }\n  }\n\n}\n\n","package spm.view\n\nimport kotlinx.html.*\nimport kotlinx.html.js.div\nimport nl.astraeus.komp.HtmlBuilder\nimport nl.astraeus.komp.Komponent\nimport nl.astraeus.komp.include\nimport org.w3c.dom.HTMLElement\nimport org.w3c.dom.HTMLTextAreaElement\nimport spm.model.Group\nimport spm.model.Password\nimport spm.state.UserState\nimport kotlin.browser.document\n\n/**\n * Created by rnentjes on 4-4-17.\n */\n\nclass SearchResult(val container: Komponent) : Komponent() {\n\n    fun findPasswords(group: Group): ArrayList<Password> {\n        val result = ArrayList<Password>()\n        val searchValue = UserState.currentSearch.trim().toLowerCase()\n\n        for (password in group.passwords) {\n            if (password.search(searchValue)) {\n                result.add(password)\n            }\n        }\n\n        for (child in group.children) {\n            result.addAll(findPasswords(child))\n        }\n\n        return result\n    }\n\n    override fun render(consumer: HtmlBuilder) = consumer.div(classes = \"col-md-9\") {\n        val topGroup = UserState.topGroup\n        var searchResult = ArrayList<Password>()\n        if (topGroup != null) {\n            searchResult = findPasswords(topGroup)\n        }\n        div(classes = \"row\") {\n            div(classes = \"col-md-6\") {\n                h3 {\n                    // background-color: #f8f8f8;\n                    style = \"text-align: center; padding: 10px; margin: 5px\"\n\n                    + \"Search result for '${UserState.currentSearch}'\"\n                }\n            }\n        }\n        hr {}\n        div {\n            //id = \"passwords_overview\"\n            div(classes = \"page-header\") {\n                h4 {\n                    +\"Found passwords\"\n                }\n            }\n            div(classes = \"row\") {\n                div(classes = \"col-md-12\") {\n                  passwordTable(searchResult, container, true)\n                }\n            }\n        }\n    }\n}\n","package spm.view\n\nimport nl.astraeus.komp.CssStyle\n\nobject Styles {\n  private val primaryColor = \"#eeeeee\"\n\n  val color: CssStyle = {\n    color = primaryColor\n  }\n\n  val font: CssStyle = {\n    fontFamily = \"Arial, courier\"\n  }\n\n  val selected: CssStyle = {\n    color = \"#444444\"\n    backgroundColor = \"#FFEB91\"\n  }\n\n  val found: CssStyle = {\n      backgroundColor = \"#FFEB91\"\n  }\n\n  val nowrap: CssStyle = {\n    whiteSpace =\"nowrap\"\n  }\n}\n","package spm.view.button\n\nimport kotlinx.html.*\nimport kotlinx.html.js.onClickFunction\nimport nl.astraeus.komp.HtmlBuilder\nimport nl.astraeus.komp.Komponent\nimport org.w3c.dom.HTMLElement\nimport org.w3c.dom.events.Event\n\n/**\n * User: rnentjes\n * Date: 11-9-17\n * Time: 20:18\n */\n\nclass PasswordButton(\n   val icon: String,\n   val text: String = \"\",\n   val tooltip: String? = null,\n   val buttonStyle: String = \"\",\n   val btnClass: String = \"btn-default\",\n   val click: (Event) -> Unit = {}\n): Komponent() {\n\n    override fun render(consumer: HtmlBuilder) = consumer.button(classes = \"btn $btnClass\") {\n        type = ButtonType.button\n        if (buttonStyle.isNotBlank()) {\n            style = buttonStyle\n        }\n        attributes[\"aria-label\"] = text\n        if (tooltip != null) {\n            title = tooltip\n        }\n\n        + text\n\n        if (icon.isNotBlank()) {\n            span(classes = \"glyphicon glyphicon-$icon\") {\n                attributes[\"aria-hidden\"] = \"true\"\n            }\n        }\n\n        onClickFunction = click\n    }\n\n}\n","package spm.view.input\n\nimport kotlinx.html.*\nimport kotlinx.html.js.div\nimport kotlinx.html.js.onBlurFunction\nimport kotlinx.html.js.onChangeFunction\nimport nl.astraeus.komp.HtmlBuilder\nimport nl.astraeus.komp.Komponent\nimport org.w3c.dom.HTMLElement\nimport org.w3c.dom.events.Event\n\n/**\n * User: rnentjes\n * Date: 1-8-17\n * Time: 17:09\n */\n\nclass SelectInput(\n  var inputId: String,\n  var inputValue: String = \"\",\n  var options: List<Pair<String, String>> = ArrayList(),\n  var placeholderText: String = \"\",\n  var error: String = \"\",\n  var label: String = \"\",\n  var readOnly: Boolean = false,\n  var blur: (Event) -> Unit = {},\n  var change: (Event) -> Unit = {}\n): Komponent() {\n\n    override fun render(consumer: HtmlBuilder) = consumer.div(classes = \"form-group\") {\n        if (error.isNotBlank()) {\n            classes += \"has-error\"\n        }\n        if (label.isNotBlank()) {\n            label(classes = \"col-md-3\") {\n                for_ = inputId\n                +label\n            }\n        }\n        div(classes = \"col-md-9\") {\n            select(classes = \"form-control\") {\n                id = inputId\n                name = inputId\n                readOnly = this@SelectInput.readOnly\n                disabled = this@SelectInput.readOnly\n\n                for (option in options) {\n                    option {\n                        value = option.first\n                        if (value == inputValue) {\n                            selected = true\n                        }\n                        + option.second\n                    }\n                }\n            }\n            if (placeholderText.isNotBlank()) {\n                attributes[\"placeholder\"] = placeholderText\n            }\n            if (error.isNotBlank()) {\n                span(classes = \"help-block\") {\n                    +error\n                }\n            }\n        }\n\n        onBlurFunction = blur\n        onChangeFunction = change\n    }\n\n}\n","package spm.view.input\n\nimport kotlinx.html.*\nimport kotlinx.html.js.onBlurFunction\nimport kotlinx.html.js.onKeyUpFunction\nimport nl.astraeus.komp.HtmlBuilder\nimport nl.astraeus.komp.Komponent\nimport org.w3c.dom.HTMLElement\nimport org.w3c.dom.events.Event\n\n/**\n * User: rnentjes\n * Date: 2-8-17\n * Time: 10:15\n */\n\nclass TextInput(\n  var inputId: String,\n  var label: String = \"\",\n  var inputValue: String = \"\",\n  var inputType: InputType = InputType.text,\n  var placeholderText: String = \"\",\n  var error: String = \"\",\n  var readOnly: Boolean = false,\n  val labelWidth: Int = 3,\n  var blur: (Event) -> Unit = {},\n  var change: (Event) -> Unit = {}\n): Komponent() {\n\n    override fun render(consumer: HtmlBuilder) = consumer.div(classes = \"form-group\") {\n        if (error.isNotBlank()) {\n            classes += \"has-error\"\n        }\n        if (label.isNotBlank()) {\n            label(classes = \"col-md-${labelWidth}\") {\n                for_ = inputId\n                +label\n            }\n        }\n        div(classes = \"col-md-${12 - labelWidth}\") {\n            input(classes = \"form-control\") {\n                id = inputId\n                name = inputId\n                type = inputType\n                value = inputValue\n                readonly = this@TextInput.readOnly\n            }\n            if (placeholderText.isNotBlank()) {\n                attributes[\"placeholder\"] = placeholderText\n            }\n            if (error.isNotBlank()) {\n                span(classes = \"help-block\") {\n                    +error\n                }\n            }\n        }\n\n        onBlurFunction = blur\n        onKeyUpFunction = change\n    }\n}\n","package spm.view.table\n\nimport kotlinx.html.Tag\nimport kotlinx.html.table\nimport kotlinx.html.tbody\nimport kotlinx.html.th\nimport kotlinx.html.thead\nimport kotlinx.html.tr\nimport nl.astraeus.komp.HtmlBuilder\nimport nl.astraeus.komp.Komponent\n\nclass Table<T>(\n    val headers: Array<String>,\n    val rows: List<T>,\n    val rowRenderer: Tag.(T) -> Unit\n): Komponent() {\n\n  override fun render(consumer: HtmlBuilder) = consumer.table(classes = \"table table-condensed table-hover\") {\n      thead {\n        tr {\n          for(header in headers) {\n            th { +header }\n          }\n        }\n      }\n      tbody {\n        for (row in rows) {\n          rowRenderer(this, row)\n        }\n      }\n  }\n\n}\n","package spm.ws\n\nimport org.w3c.dom.WebSocket\nimport spm.mainComponent\nimport spm.state.UserState\nimport spm.view.Modal\n\n/**\n * Created by rnentjes on 7-6-16.\n */\n\nprivate var nextCallbackId = 0L\nfun nextCallbackId(): Long = ++nextCallbackId;\n\nobject CommandDispatcher {\n    val commands: MutableMap<String, (ws: org.w3c.dom.WebSocket, tk: spm.ws.Tokenizer) -> Unit> = HashMap()\n    var loginListener: ((WebSocket, Tokenizer) -> Unit)? = null\n    val callbacks: MutableMap<String, (WebSocket, Tokenizer) -> Unit> = mutableMapOf()\n\n    // LOCKED, obtained lock\n    // BLOCKED, unable to get lock\n    // UNLOCKED, nobody has lock\n    init {\n        commands[\"LOGIN\"] = this::login\n        commands[\"ALERT\"] = { ws, tk -> Modal.showAlert(tk.next(), tk.next()) }\n        commands[\"RESPONSE\"] = { ws, tk ->\n            val callbackId = tk.next()\n\n            callbacks[callbackId]?.invoke(ws, tk)\n            callbacks.remove(callbackId)\n        }\n        commands[\"PASSWORD_UPDATED\"] = { ws, tk ->\n            Modal.showAlert(\"Success\", \"Password successfully updated!\")\n        }\n        commands[\"UNLOCKED\"] = { ws, tk ->\n            UserState.readOnly = false\n            UserState.obtainedLock = false\n\n            val currentGroupId: Long? = UserState.currentGroup?.id\n            UserState.loadData(tk.next())\n            currentGroupId?.let { id ->\n                UserState.currentGroup = UserState.topGroup?.findById(id)\n            }\n\n            mainComponent.update()\n        }\n        commands[\"BLOCKED\"] = { ws, tk ->\n            UserState.readOnly = true\n            UserState.obtainedLock = false\n\n            mainComponent.update()\n        }\n    }\n\n    fun login(ws: WebSocket, tk: Tokenizer) {\n        val ll = loginListener\n\n        if (ll != null) {\n            ll(ws, tk)\n        }\n    }\n\n    fun handle(ws: WebSocket, msg: String) {\n        val tk = Tokenizer(msg)\n        val cmd = tk.next()\n\n        val command = commands[cmd] ?: throw IllegalStateException(\"Don't know how to handle command [$cmd]\")\n\n        command.invoke(ws, tk)\n    }\n\n    fun setLoginListener(func: (WebSocket, Tokenizer) -> Unit) {\n        loginListener = func\n    }\n}\n","package spm.ws\n\n/**\n * User: rnentjes\n * Date: 10-2-16\n * Time: 10:57\n */\n\n/**\n * read text as tokens\n * tokens are seperated by <seperator> e.g. ~\n * <seperator> is escaped by <escape> e.g. `~\n */\nclass Tokenizer(val txt: String = \"\", val seperator: Char = '~', val escape: Char = '`') {\n    var index = 0\n\n    fun done() = index >= txt.length\n\n    fun next(): String {\n        //println(\"Getting next $index/${txt.length} -> $txt\")\n        val result = StringBuilder()\n        var escaped = false\n\n        if (done()) {\n            //println(\"Next is ''\")\n\n            return \"\"\n        }\n\n        while(!done()) {\n            val ch = txt[index]\n\n            if (escaped) {\n                result.append(ch)\n                escaped = false\n            } else {\n                when (ch) {\n                    escape -> {\n                        escaped = true\n                    }\n                    seperator -> {\n                        index++\n                        return result.toString()\n                    }\n                    else -> {\n                        result.append(ch)\n                    }\n                }\n            }\n\n            index++\n        }\n\n        //println(\"Next is '$result'\")\n        return result.toString()\n    }\n\n    fun tokenize(vararg parts: String): String {\n        val result = StringBuilder()\n\n        for (part in parts) {\n            if (result.isNotEmpty()) {\n                result.append(seperator)\n            }\n            result.append(escape(part))\n        }\n\n        return result.toString()\n    }\n\n    override fun toString(): String{\n        return \"Tokenizer(index=$index, txt='$txt')\"\n    }\n\n    fun escape(txt: String): String {\n        val result = StringBuilder()\n\n        for (index in 0..txt.length-1) {\n            val ch = txt[index]\n\n            when(ch) {\n                escape -> {\n                    result.append(\"$escape$escape\")\n                }\n                seperator -> {\n                    result.append(\"$escape$seperator\")\n                }\n                else -> {\n                    result.append(ch)\n                }\n            }\n        }\n\n        return result.toString()\n    }\n\n    companion object {\n        fun tokenize(vararg parts: String): String {\n            val tokenizer = Tokenizer()\n\n            return tokenizer.tokenize(*parts)\n        }\n    }\n}\n\nfun deTokenize(str: String, indent: Int = 1, seperator: Char = '~', escape: Char = '`') {\n    val t = Tokenizer(str, seperator, escape)\n    var first = true\n\n    while(!t.done()) {\n        val next = t.next()\n        for(count in 0..indent-1) {\n            print(\"-\")\n        }\n        //println(\">$next\")\n\n        if (!t.done() || !first) {\n            deTokenize(next, indent+1, seperator, escape)\n        }\n\n        first = false\n    }\n}\n","package spm.ws\n\nimport kotlinx.html.dom.create\nimport kotlinx.html.id\nimport kotlinx.html.js.div\nimport org.w3c.dom.HTMLElement\nimport org.w3c.dom.MessageEvent\nimport org.w3c.dom.WebSocket\nimport org.w3c.dom.events.Event\nimport spm.state.UserState\nimport spm.view.Modal\nimport spm.view.RemovePasswordConfirm\nimport kotlin.browser.document\nimport kotlin.browser.window\n\n/**\n * User: rnentjes\n * Date: 26-11-16\n * Time: 12:08\n */\n\nobject WebSocketConnection {\n    var websocket: WebSocket? = null\n    var loadingCalls: Int = 0\n    var interval: Int = 0\n\n    fun open() {\n        close()\n\n        if (window.location.hostname.contains(\"localhost\") || window.location.hostname.contains(\"192.168\")) {\n            websocket = WebSocket(\"ws://${window.location.hostname}:${window.location.port}/ws\")\n        } else {\n            websocket = WebSocket(\"wss://${window.location.hostname}/ws\")\n        }\n\n        val ws = websocket\n\n        if (ws != null) {\n            ws.onopen = { onOpen(ws, it) }\n            ws.onmessage = { onMessage(ws, it) }\n            ws.onclose = { onClose(ws, it) }\n            ws.onerror = { onError(ws, it) }\n        }\n    }\n\n    fun close() {\n        websocket?.close(-1, \"Application closed socket.\")\n    }\n\n    fun onOpen(ws: WebSocket, event: Event) {\n        WebSocketConnection.doneLoading()\n\n        if (UserState.loginname != null && UserState.loginPasswordHash != null) {\n            send(\"LOGIN\",\n              UserState.loginname ?: throw IllegalStateException(\"Whut!\"),\n              UserState.loginPasswordHash ?: throw IllegalStateException(\"Whut!\")\n            )\n        }\n\n        interval = window.setInterval({\n            val actualWs = websocket\n\n            if (actualWs != null) {\n                ws.send(\"OK\")\n            } else {\n                window.clearInterval(interval)\n                //MainView.logout()\n\n                Modal.showAlert(\"Error\", \"Connection to the server was lost!\\nPlease try again later.\")\n                WebSocketConnection.loading()\n                reconnect()\n            }\n        }, 10000)\n    }\n\n    fun reconnect() {\n        val actualWs = websocket\n\n        if (actualWs != null) {\n            Modal.showAlert(\"Succes\", \"Connection with the server was restored!\")\n        } else {\n            open()\n\n            window.setTimeout({\n                reconnect()\n            }, 1000)\n        }\n    }\n\n    fun onMessage(ws: WebSocket, event: Event) {\n        if (event is MessageEvent) {\n            val data = event.data\n\n            if (data is String) {\n                CommandDispatcher.handle(ws, data)\n            }\n        }\n    }\n\n    fun onClose(ws: WebSocket, event: Event): dynamic {\n        websocket = null\n\n        return \"dynamic\"\n    }\n\n    fun onError(ws: WebSocket, event: Event): dynamic {\n        println(\"Error websocket! $ws\")\n\n        websocket = null\n\n        return \"dynamic\"\n    }\n\n    fun send(message: String) {\n        websocket?.send(message)\n\n        if (websocket == null) {\n            if (!UserState.loggedIn) {\n                UserState.clear()\n            }\n            Modal.showAlert(\"Error\", \"Cannot connect to the server!\")\n        }\n    }\n\n    fun send(vararg args: String) {\n        send(Tokenizer.tokenize(*args))\n    }\n\n    fun lock(callback: (WebSocket, Tokenizer) -> Unit) {\n        val nextId = \"${nextCallbackId()}\"\n        CommandDispatcher.callbacks[nextId] = callback\n        send(Tokenizer.tokenize(\"LOCK\", nextId))\n    }\n\n    fun getLoadingDiv(): HTMLElement {\n        var result = document.getElementById(\"loading_div\")\n\n        if (result == null) {\n            result = document.create.div(classes = \"loading\") {\n                id = \"loading_div\"\n                +\"Loading&8230;\"\n            }\n            document.body?.appendChild(result)\n        }\n\n        return result as HTMLElement\n    }\n\n    fun loadingWork(callback: () -> Unit = {}) {\n        loadingCalls++\n\n        if (loadingCalls >= 1) {\n            // hide interface\n            getLoadingDiv().style.display = \"block\"\n        }\n\n        window.requestAnimationFrame {\n            window.requestAnimationFrame {\n                try {\n                    callback()\n                } finally {\n                    doneLoading()\n                }\n            }\n        }\n    }\n\n    fun loading(callback: () -> Unit = {}) {\n        loadingCalls++\n\n        if (loadingCalls >= 1) {\n            // hide interface\n            getLoadingDiv().style.display = \"block\"\n        }\n\n        try {\n            callback()\n        } finally {\n            doneLoading()\n        }\n    }\n\n    fun doneLoading() {\n        if (loadingCalls > 0) {\n            loadingCalls--\n        }\n\n        if (loadingCalls == 0) {\n            // show interface\n            getLoadingDiv().style.display = \"none\"\n        }\n    }\n\n}\n"],"names":[],"mappings":"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"}